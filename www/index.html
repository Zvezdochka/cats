<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head> 
    <meta http-equiv="content-type" content="text/html; charset=utf-8"> 
<!-- 	<script src="http://ajax.googleapis.com/ajax/libs/dojo/1.7.2/dojo/dojo.js" data-dojo-config="async: true"></script> -->
  
<!--    <link href="style.css" type="text/css" rel="stylesheet" />    -->

    <script type="text/javascript" src="http://mbostock.github.com/d3/d3.v2.js?2.9.1"></script> 
  </head> 

    <body> 
        <div style="float: left; width: 2500px; margin-right: -400px; height: 100%;">  
            <embed id="emb" src="shreda.svg" width="100%" height="100%" type="image/svg+xml" />
        </div>
        <div style="float: left; width: 400px; height: 100%;">
            <embed id="slider_wind" width="100%"  src="slider.svg" type="image/svg+xml" /><br>
            <embed id="slider_gravity" width="100%" src="slider.svg" type="image/svg+xml" />
        </div>
	<script>
    var catNames = [];
    var cats = [];
    var mice = [];
    var canvas;
    var windOffset = 0;
    var pos = 0;
    var gravity = 0;
	var catSelector = null;
	
	var Mouse = function()
    {

    }
    
    var CatSelector = function(selectorGroupId, canvas)
	{
		var that = this;
		that.canvas = canvas; 
		that.selector = null;
		that.buttons = {rotate: null};

		that.construct = function()
		{
			that.selector = that.canvas.select('#' + selectorGroupId);
			that.buttons.rotate = that.selector.select('#buttonRotate');
			that.buttons.rotate.on('mousedown', that.buttonRotatePress);
		}

		that.buttonRotatePress = function()
		{
            that.canvas.on('mousemove', that.buttonRotateMove(d3.event));
			that.canvas.on('mouseup', that.buttonRotateRelease);            
		}

		that.buttonRotateMove = function(mouseDownEvent)
		{
			var catObj = mouseDownEvent.target.correspondingUseElement.cat;

			var selectorCentre = catObj.getCentre();
            var catMatrix = catObj.catNode.node().getScreenCTM();
            selectorCentre = selectorCentre.matrixTransform(catMatrix);

            var startPoint = {
                x: mouseDownEvent.x-selectorCentre.x,
                y: selectorCentre.y-mouseDownEvent.y
            }
            var startAngle = Math.atan(startPoint.y / startPoint.x);
            startAngle = that.radToDeg(startAngle);
            var anglePos = startAngle;

            console.info('Start angle', startAngle);
            
			return function() {
                var angleOffset;
                var mouseMoveEvent = d3.event;
                
                var movePoint = {
                    x: mouseMoveEvent.x-selectorCentre.x,
                    y: selectorCentre.y-mouseMoveEvent.y
                }
                
                var angle = Math.atan(movePoint.y / movePoint.x);
                console.info('Angle', that.radToDeg(angle));
                
                if (movePoint.x < 0 && movePoint.y > 0)
                {
                    console.info('Quadrant 4');
                    angle += Math.PI;
                    console.info('Corrected angle', that.radToDeg(angle));
                }
                else if (movePoint.x < 0 && movePoint.y < 0)
                {
                    console.info('Quadrant 3');
                    angle -= Math.PI;
                    console.info('Corrected angle', that.radToDeg(angle));
                }
                
                angle = that.radToDeg(angle);
                angleOffset = -(angle - anglePos);
                anglePos = angle;

				console.info('offset', angleOffset);
                catObj.rotate(angleOffset);
			}
		}

        that.radToDeg = function(radian)
        {
            return radian * 180 / Math.PI;
        }
        
		that.buttonRotateRelease = function()
		{
			console.info("mouseUp");
            that.canvas.on('mousemove', null);
		}

		that.construct();
	}

    var Cat = function(name, catNode, canvas)
	{
		var that = this;
		that.catName = name;
		that.lastX = null;
		that.lastY = null;
		that.pos = {x: 0, y: 0};
		that.catNode = catNode;
        that.canvas = canvas;
		that.selectionMarker = null;
        that.catAnnihilatorPower = 30;
		that.events =
        {
            'catPreselect' : function()
            {
                var centre = that.getCentre();
                var catMatrix = that.catNode.node().getScreenCTM();
                centre = centre.matrixTransform(catMatrix);
                var selectorBoundBox = canvas.select('#selector').node().getBBox();
                that.selectionMarker = canvas.select('#markerGroup')
                      .append('use')
                      .attr('xlink:href', '#selector')
                      .attr('x', centre.x - selectorBoundBox.width / 2)
                      .attr('y', centre.y - selectorBoundBox.height / 2)
                      .classed('pre', true)
                      .classed('selector', true);
                //that.selectionMarker.bind('cat', this);
                that.selectionMarker.node().cat = that;
                that.selectionMarker.on('mouseout', that.events.catDeselect);
            },

            'catDeselect' : function()
            {
                that.selectionMarker.remove();
                that.selectionMarker = null;
            },

            'catchCat' : function()
            {
                canvas.on('mousemove', that.events.moveCat);
                canvas.on('mouseup', that.events.releaseCat);
                that.lastX = d3.event.x;
                that.lastY = d3.event.y;
                that.pos.x = that.catNode.attr('x')*1;
                that.pos.y = that.catNode.attr('y')*1;

                console.info('initialPos',that.pos);
                console.info('catNodeAtr',that.catNode);
            },

            'moveCat' : function()
            {
                var offsetX = d3.event.x - that.lastX;
                that.lastX = d3.event.x;

                var offsetY = d3.event.y - that.lastY;
                that.lastY = d3.event.y;

                that.pos.x += offsetX;
                that.pos.y += offsetY;
                that.catNode.attr('x', that.pos.x);
                that.catNode.attr('y', that.pos.y);
                if (that.selectionMarker)
                {
                    that.selectionMarker.attr('cx', that.selectionMarker.attr('cx')*1 + offsetX);
                    that.selectionMarker.attr('cy', that.selectionMarker.attr('cy')*1 + offsetY);
                }
            },

            'releaseCat' : function()
            {
                canvas.on('mousemove', null);
            }
        }

	    that.construct = function()
	    {
			catNode.on('mousedown', that.events.catchCat);
            catNode.on('mouseover', that.events.catPreselect);
	    }

        that.getCentre = function()
        {
            var catBoundBox = that.catNode.node().getBBox();
            var centre = canvas.node().createSVGPoint();
            centre.x = that.catNode.attr('x')*1 + catBoundBox.width / 2;
            centre.y = that.catNode.attr('y')*1 + catBoundBox.height / 2;
            return centre;
        }

	    that.rotate = function(angle)
        {
            var domCat = that.catNode.node();
            var matrixTransformGroupToCat = domCat.getTransformToElement(domCat.parentNode);
            matrixTransformGroupToCat = matrixTransformGroupToCat.translate(that.getCentre().x, that.getCentre().y);
            matrixTransformGroupToCat = matrixTransformGroupToCat.rotate(angle);
            matrixTransformGroupToCat = matrixTransformGroupToCat.translate(-that.getCentre().x, -that.getCentre().y);
            var m = (m = matrixTransformGroupToCat, [m.a, m.b, m.c, m.d, m.e, m.f].join(' '));
            that.catNode.attr('transform', 'matrix('+m+')');
        }

	    that.construct();
	}

    // fetches the document for the given embedding_element
	function getSubDocument(embedding_element)
	{
		if (embedding_element.contentDocument)
		{
			return embedding_element.contentDocument;
		}
		else
		{
			var subdoc = null;
			try
			{
				subdoc = embedding_element.getSVGDocument();
			} catch(e) {}
			return subdoc;
		}
	}

    function redraw()
    {
        var cats = canvas.select('#catGroup')
        				 .selectAll('.cat')
                         .data(catNames)
                         .enter()
                             .append('use')
                             .attr('xlink:href', '#shreda')
                             .attr('x', function(d, i){return i*200})
                             .attr('y', 0)
                             .style('opacity','0')
                             .classed('cat', true)
                             .call(initCats)
                         .transition()
                             .duration(3000)
                             .style('opacity', '1')
                             .each('end', function() {
                                  d3.select(this)
                                    .transition()
                                        //.delay(function(d, i) { return d3.random.normal(500, 500)(); })
                                        .duration(250 / (gravity+1) *10)
                                        .attr('transform', 'translate(' + windOffset + ', 250)');
                             });
    }

	function findSVG(embed_id)
	{
		var obj = document.getElementById(embed_id);
        var subDoc = getSubDocument(obj);
        var svg = d3.select(subDoc).select('svg');
        return svg;
	}

	function initCats(catsSelection)
	{
		catsSelection.each(function(name)
		{
			cats.push(new Cat(name, d3.select(this), canvas));
		})
	}

	function initSlider(sliderObj, on_pos)
	{
		var pos = 0;
		var pointerObj = sliderObj.select("#pointer");
		var stripe = sliderObj.select("#stripe");
		var stripeLength = stripe.node().getBBox().width;

		pointerObj.on('mousedown', function()
		{
			var lastX = d3.event.x;
			sliderObj.on('mousemove', function()
			{
				var moveOffset = d3.event.x - lastX;
				if (((pos + moveOffset) > stripeLength) || (pos + moveOffset < 0))
				{
					return ;
				}
				pos += moveOffset;
				lastX = d3.event.x;
				pointerObj.attr('transform', 'translate('+ pos +', 0)');

				var newPos = Math.round(pos / stripeLength * 100);
				on_pos(newPos);
			})
			sliderObj.on('mouseup', function()
			{
				sliderObj.on('mousemove', null);
			});
		})
	}

	function redrawMice()
    {
        canvas.selectAll("use.mouse")
            .data(nodes)
            .enter()
                .insert("use")
                .attr('xlink:href', '#mouse')    
                .attr("class", "mouse")
                .attr("x", function(d) { return d.x; })
                .attr("y", function(d) { return d.y; })
                .call(force.drag)
                .on('dblclick', function(d)
        {
            
            //finÐ² cat-actor
            cats.forEach(function(cat)
            {
                var distanceX = cat.pos.x - d.x;
                var distanceY = cat.pos.y - d.y;
                if (sqrt(distanceX * distanceX + distanceY * distanceY) <= cat.catAnnihilatorPower)
                {
                    // mouse enough close
                    
                }
            })
            // find nearly nodes
            //push
        }
    }
    
    function redrawMiceLinks()
    {
        canvas.selectAll("line.mouseLink")
            .data(links)
            .enter()
                .insert("line")
                .attr("class", "mouseLink")
                .attr("x1", function(d) { return d.source.x; })
                .attr("y1", function(d) { return d.source.y; })
                .attr("x2", function(d) { return d.target.x; })
                .attr("y2", function(d) { return d.target.y; });
    }

    function init()
	{
			canvas = findSVG('emb');
			canvas.append('g').attr('id','markerGroup');
			canvas.append('g').attr('id','catGroup');

			// wind
			var sliderWind = findSVG('slider_wind');
			initSlider(sliderWind, function(new_pos) {
				windOffset = new_pos * 1.5;
			});

			// gravity
			var sliderGravity = findSVG('slider_gravity');
			initSlider(sliderGravity, function(new_pos)
			{
				gravity = new_pos;
			});

            var nodes = [];
            var links = [];
            var force = d3.layout.force()
                .nodes(nodes)
                .links(links)
                .size([canvas.node().clientWidth, canvas.node().clientHeight]);

            canvas.on('click', function()
            {
				if (d3.event.target == canvas.node())
				{
	            	catNames.push('shreda');
	                redraw();
                    
                    if (d3.event.ctrlKey) 
                    {
                          var point = d3.svg.mouse(this),
                              node = {x: point[0], y: point[1]},
                              n = nodes.push(node);
                          redrawMice();    
                    }
                }
            })

            /*create instance of selector*/
            catSelector = new CatSelector('selector', canvas);
	}
	// wait until all the resources are loaded
	window.addEventListener("load", init, false);

    </script>
  </body>
</html>